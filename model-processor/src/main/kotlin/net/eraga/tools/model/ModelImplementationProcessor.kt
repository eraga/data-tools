package net.eraga.tools.model

import com.squareup.kotlinpoet.*
import net.eraga.tools.model.ModelImplementationProcessor.Companion.PROCESSED_ANNOTATION
import net.eraga.tools.models.*
import java.io.File
import java.io.Serializable
import javax.annotation.processing.*
import javax.lang.model.SourceVersion
import javax.lang.model.element.ElementKind
import javax.lang.model.element.ExecutableElement
import javax.lang.model.element.TypeElement
import javax.lang.model.type.MirroredTypeException
import javax.lang.model.util.Elements
import javax.lang.model.util.Types
import javax.tools.Diagnostic
import kotlin.reflect.full.createInstance

/**
 * Date: 27/06/2018
 * Time: 16:21
 */
@SupportedAnnotationTypes(PROCESSED_ANNOTATION)
@SupportedSourceVersion(SourceVersion.RELEASE_8)
class ModelImplementationProcessor : AbstractProcessor() {
    companion object {
        const val PROCESSED_ANNOTATION = "net.eraga.tools.models.ImplementModel"

        private fun primitiveInitializersMap(mappings: PrimitiveInitializers?): Map<String, Any?> {
            val defaults = mappings ?: PrimitiveInitializers::class.createInstance()

            val map = HashMap<String, Any?>()

            map["Boolean"] = defaults.Boolean
            map["Byte"] = defaults.Byte
            map["Double"] = defaults.Double
            map["Float"] = defaults.Float
            map["Int"] = defaults.Int
            map["Short"] = defaults.Short
            map["String"] = "\"${defaults.String}\""

            return map
        }

        private fun classInitializersMap(initializers: ClassInitializers?): Map<TypeName, ClassName> {
            val model = initializers ?: ClassInitializers::class.constructors.first().call(arrayOf<ClassMapping>())
            val map = HashMap<TypeName, ClassName>()

            model.classMappingDefaults().forEach {
                val source = try {
                    it.key.asTypeName()
                } catch (e: MirroredTypeException) {
                    e.typeMirror.asTypeName().javaToKotlinType()
                }

                val target = try {
                    it.value.asClassName()
                } catch (e: MirroredTypeException) {
                    ClassName.bestGuess(e.typeMirror.asTypeName().javaToKotlinType().toString())
                }

                map[source] =
                        target
            }

            model.list.forEach {
                val source = try {
                    it.source.asTypeName()
                } catch (e: MirroredTypeException) {
                    e.typeMirror.asTypeName().javaToKotlinType()
                }

                val target = try {
                    it.target.asClassName()
                } catch (e: MirroredTypeException) {
                    ClassName.bestGuess(e.typeMirror.asTypeName().javaToKotlinType().toString())
                }

                map[source] =
                        target
            }

            return map
        }
    }

    private val kotlinGenerated by lazy { processingEnv.options["kapt.kotlin.generated"] }

    private lateinit var messager: Messager
    private lateinit var typeUtils: Types
    private lateinit var elementsUtil: Elements
    private lateinit var filer: Filer

    override fun init(processingEnv: ProcessingEnvironment) {
        super.init(processingEnv)
        messager = processingEnv.messager
        typeUtils = processingEnv.typeUtils
        elementsUtil = processingEnv.elementUtils
        filer = processingEnv.filer
    }

    override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {
        val elements = annotations.filter { it.qualifiedName.contentEquals(PROCESSED_ANNOTATION) }
                .map { roundEnv.getElementsAnnotatedWith(it) }
                .flatMap { it }
                .filterIsInstance<TypeElement>()

        if (elements.any()) {

            File(kotlinGenerated).mkdirs()
            elements.forEach {
                if(it.kind.isInterface) {
                    generateImplementation(it, elements.map { it.qualifiedName.toString() })
                } else {
                    messager.printMessage(Diagnostic.Kind.ERROR, "Only interfaces can be annotated with " +
                            "$PROCESSED_ANNOTATION: ${it.qualifiedName} is ${it.kind.name}")
                }
            }
        }

        return true
    }


    private fun gatherGetters(element: TypeElement): List<ExecutableElement> {
        val getters = ArrayList<ExecutableElement>()

//        println("$element has superinterfaces: ${element.interfaces}")

        for (iface in element.interfaces) {
            val realElement = typeUtils.asElement(iface)
            if (realElement is TypeElement) {
                getters.addAll(gatherGetters(realElement))
            } else {
//                println("realElement is $realElement")
            }
        }

        getters.addAll(element.enclosedElements.filterIsInstance<ExecutableElement>())

        return getters
    }


    class ModelMetadata(element: TypeElement) {
        val modelSettings = element.getAnnotation(ImplementModel::class.java)!!
        val interfaceClassName = element.simpleName.toString()
        val baseName = interfaceClassName.removeSuffix(modelSettings.modelSuffix)
        val elementPackage = element.qualifiedName.removeSuffix(".$interfaceClassName").toString()

        val mutableInterfaceName = "$baseName${modelSettings.mutableSuffix}"
        val implClassName = "$baseName${modelSettings.implSuffix}"
        val dslFunctionName = implClassName.decapitalize()
        val primitiveInitializers = primitiveInitializersMap(element.getAnnotation(PrimitiveInitializers::class.java))
        val classInitializers = classInitializersMap(element.getAnnotation(ClassInitializers::class.java))
    }


    private fun generateImplementation(element: TypeElement, elements: List<String>) {
        val metadata = ModelMetadata(element)


        val superInterfaceClass = ClassName(
                metadata.elementPackage,
                metadata.interfaceClassName)

        val mutableInterfaceClass = ClassName(
                metadata.elementPackage,
                metadata.mutableInterfaceName)

        val implementationClass = ClassName(
                metadata.elementPackage,
                metadata.implClassName)


        val mutableInterfaceBuilder = TypeSpec.interfaceBuilder(mutableInterfaceClass)
                .addSuperinterface(superInterfaceClass)

        val classBuilder = TypeSpec.classBuilder(implementationClass)

        val constructorBuilder = FunSpec.constructorBuilder()

        val propertySet = HashSet<PropertySpec>()
        for (property in gatherGetters(element)) {
            val propName = property.simpleName.toString()
            if (!propName.startsWith("get"))
                continue
            val name = propName.replace("get", "").decapitalize()
            val type = property.returnType.asTypeName().javaToKotlinType(property)

            val kotlinProperty = PropertySpec.varBuilder(
                    name,
                    type,
                    KModifier.OVERRIDE)

            mutableInterfaceBuilder.addProperty(kotlinProperty.build())

            val defaultValue = if (type.nullable) {
                "null"
            } else {
                val returnType = typeUtils.asElement(property.returnType)
                if (returnType?.kind == ElementKind.ENUM) {
                    "$type.values()[0]"
                } else {
                    val simpleTypeName = type.toString().split(".").last()

                    if (metadata.primitiveInitializers.containsKey(simpleTypeName)) {
                        metadata.primitiveInitializers[simpleTypeName].toString()
                    } else {
                        if (elements.contains("$type") && returnType is TypeElement) {
                            val meta = ModelMetadata(returnType)
                            "${meta.implClassName}()"
                        } else {
                            type.classToInitializer(metadata.classInitializers)
                        }
                    }
                }
            }

            constructorBuilder.addParameter(ParameterSpec.builder(
                    name,
                    type)
                    .defaultValue(defaultValue)
                    .build())

            propertySet.add(kotlinProperty.initializer(name).build())
        }

        val classModifier = if (metadata.modelSettings.classKind == Kind.OPEN) {
            KModifier.OPEN
        } else {
            KModifier.DATA
        }

        classBuilder
                .addModifiers(classModifier)
                .addSuperinterface(mutableInterfaceClass)
                .primaryConstructor(constructorBuilder.build())
                .addProperties(propertySet)

        if(metadata.modelSettings.serializable) {
            classBuilder.addSuperinterface(Serializable::class)
        }


        val fileBuilder = FileSpec.builder(metadata.elementPackage, metadata.implClassName)
                .addType(mutableInterfaceBuilder.build())
                .addType(classBuilder.build())

        if (metadata.modelSettings.dsl) {
            val funBody = CodeBlock.builder()
                    .add("""
val instance = %T()
instance.init()
return instance
""".trimStart('\n'), implementationClass)
                    .build()

            val dslFun = FunSpec.builder(metadata.dslFunctionName)
                    .addParameter(
                            ParameterSpec.builder(
                                    "init",
                                    LambdaTypeName.get(
                                            receiver = implementationClass,
                                            returnType = UNIT
                                    )).build())
                    .addCode(funBody)
                    .returns(superInterfaceClass)

            fileBuilder.addFunction(dslFun.build())
        }

        val file = fileBuilder.build()

        file.writeTo(File(kotlinGenerated))
    }
}
